Отличная идея! Это амбициозный, но выполнимый проект. Вот список задач, оформленный для загрузки в Jira. Описания задач составлены как промты для Cursor IDE, содержащие контекст, конкретные требования и технические детали.

---

### **Эпик: Разработка P2P приложения для видеозвонков "Call Mom"**

---

### **Задача 1: Настройка базового проекта React Native (Expo)**
**Тип:** Техническая подготовка
**Приоритет:** Highest
**Описание:**
Необходимо создать и настроить базовый проект на React Native с использованием Expo. Проект должен быть готов к дальнейшей разработке с использованием библиотек для WebRTC.

**Промт для Cursor:**
```
Создай новый проект React Native с использованием Expo. Используй самый стабильный TypeScript шаблон (npx create-expo-app --template). Убедись, что структура проекта чистая и готова для добавления новых модулей. Проверь, что зависимости для работы с камерой и микрофоном (expo-av, expo-camera) могут быть легко добавлены. Инициализируй git-репозиторий.
```
---

### **Задача 2: Проектирование и реализация механизма P2P-соединения (WebRTC)**
**Тип:** Разработка
**Приоритет:** Highest
**Описание:**
Реализовать ядро приложения - установление прямого Peer-to-Peer (P2P) соединения между двумя устройствами с использованием WebRTC. Задача включает в себя обмен SDP-оферами/ответами и ICE-кандидатами через сторонний канал (сигналинг).

**Промт для Cursor:**
```
Нам нужно реализовать бессерверное P2P-соединение между двумя клиентами React Native с использованием WebRTC.
1.  Установи необходимые пакеты: `react-native-webrtc` (и настрой его для Expo) или найди совместимую альтернативу.
2.  Создай модуль (например, `src/services/WebRTCService.ts`), который будет инкапсулировать логику:
    -   Создание `RTCPeerConnection` с конфигурацией STUN-серверов (например, `stun:stun.l.google.com:19302`). TURN-серверы не используем для простоты.
    -   Генерация SDP-офера (`createOffer`) и установка локального описания (`setLocalDescription`).
    -   Обработка удаленного SDP-ответа (`setRemoteDescription`).
    -   Сбор и обработка ICE-кандидатов.
3.  Соединение должно быть защищено: установи `sdpSemantics: 'unified-plan'` и убедись, что используются DTLS и SRTP.
4.  Логика должна быть организована так, чтобы строки SDP и ICE-кандидатов можно было легко передать другому участнику (например, скопировать в буфер обмена) и ввести с другой стороны.
```
---

### **Задача 3: Реализация простого сигналинга через обмен ссылками/кодами**
**Тип:** Разработка
**Приоритет:** High
**Описание:**
Так как мы не используем сервер для сигналинга, необходимо реализовать механизм, при котором пользователи могут обмениваться данными соединения (SDP и ICE) через другие приложения (мессенджеры, почта). Данные должны быть закодированы в виде ссылки или удобного для копирования текста.

**Промт для Cursor:**
```
Реализуй механизм "сигналинга" через обмен текстовыми данными.
1.  Создай функцию в `WebRTCService.ts` для сериализации данных о предложении соединения (SDP offer) в компактную строку. Используй `base64` кодирование для удобства.
2.  Создай функцию для десериализации этой строки и парсинга полученного SDP предложения/ответа.
3.  На экране контактов/звонка реализуй кнопку "Позвонить", которая:
    -   Генерирует SDP офер.
    -   Конвертирует его в строку и создает глубокую ссылку (deep link) вида `callmom://call?offer=<base64_data>` или отображает строку в модальном окне с кнопкой "Скопировать".
4.  Реализуй обработку глубокой ссылки (или экран "Принять звонок", куда можно вставить скопированный код) для извлечения данных SDP офера и начала процесса установления соединения с инициатором.
```
---

### **Задача 4: Разработка интерфейса списка контактов**
**Тип:** Разработка UI
**Приоритет:** High
**Описание:**
Создать первый экран приложения - список контактов. Контакты должны храниться локально на устройстве. Возможность добавления нового контакта путем ввода/вставки полученной извне ссылки-приглашения.

**Промт для Cursor:**
```
Создай экран "Контакты" (`src/screens/ContactsScreen.tsx`).
1.  Используй `AsyncStorage` или `expo-secure-store` для локального хранения списка контактов. Контакт - это объект с `id`, `name` и `signalData` (последняя использованная ссылка для соединения).
2.  Экран должен отображать список сохраненных контактов. Для каждого контакта есть кнопка "Позвонить".
3.  В верхней части экрана должна быть кнопка "Добавить контакт". По нажатию открывается модальное окно с полем для ввода глубокой ссылки (или base64 строки), полученной от другого пользователя.
4.  При обработке ссылки, из нее должен извлекаться публичный ключ или идентификатор пользователя, который сохраняется в список контактов под введенным именем.
Интерфейс должен быть максимально простым: только список и две кнопки.
```
---

### **Задача 5: Разработка экрана видеозвонка**
**Тип:** Разработка UI
**Приоритет:** High
**Описание:**
Реализовать экран совершения видеозвонка. На экране отображается видео с фронтальной камеры собеседника и, возможно, свое видео (picture-in-picture). Единственный элемент управления - большая красная кнопка завершения вызова.

**Промт для Cursor:**
```
Создай экран видеозвонка (`src/screens/CallScreen.tsx`).
1.  Экран должен занимать весь размер окна.
2.  Используй компонент `RTCView` из `react-native-webrtc` для отображения видеопотока с удаленного пира (`remoteStream`). Видео должно быть на весь экран.
3.  В углу экрана (например, сверху справа) размести маленький `RTCView` для отображения локального потока (`localStream`) по принципу picture-in-picture.
4.  В центре нижней части экрана размести большую круглую красную кнопку с иконкой телефона (завершение вызова). Иконку можно взять из `@expo/vector-icons`.
5.  По нажатию на кнопку соединение должно разрываться, все медиапотоки закрываться, а пользователь возвращаться на экран контактов.
```
---

### **Задача 6: Интеграция медиапотоков (камера, микрофон)**
**Тип:** Разработка
**Приоритет:** High
**Описание:**
Настроить получение медиапотоков с фронтальной камеры и микрофона устройства и их передачу в WebRTC соединение.

**Промт для Cursor:**
```
Доработай `WebRTCService.ts`, добавив работу с медиапотоками.
1.  Создай функцию `getMediaStream()`, которая использует `mediaDevices.getUserMedia` (или его аналог из `react-native-webrtc`) для получения доступа к фронтальной камере и микрофону с базовыми настройками качества (например, 640x480, 30fps).
2.  Полученный локальный поток (`localStream`) должен быть добавлен в `RTCPeerConnection` с помощью `addTrack` для каждого трека.
3.  Настрой обработку входящего удаленного потока (`ontrack` событие) и его сохранение в состоянии для отображения в `RTCView` на экране звонка.
4.  Убедись, что при завершении вызова потоки корректно останавливаются (`stop()` на всех треках).
```
---

### **Задача 7: Обработка состояний соединения и ошибок**
**Тип:** Разработка
**Приоритет:** Medium
**Описание:**
Реализовать обработку различных состояний соединения (подключение, соединение установлено, сбой) и отображение соответствующих уведомлений пользователю (например, "Вызов...", "Нет ответа").

**Промт для Cursor:**
```
Добавь обработку состояний WebRTC соединения для улучшения UX.
1.  В `WebRTCService.ts` подпишись на события соединения: `onconnectionstatechange`, `oniceconnectionstatechange`.
2.  Пробрасывай эти состояния (например, 'connecting', 'connected', 'failed', 'disconnected') через хуки или контекст в UI.
3.  На экране звонка, пока соединение в состоянии 'connecting', поверх видео отображай оверлей с текстом "Вызов..." или индикатором загрузки.
4.  Если состояние меняется на 'failed' или 'disconnected', автоматически разрывай вызов и показывай пользователю уведомление (например, с помощью `Alert.alert`) с причиной "Соединение прервано".
```
---

### **Задача 8: Базовое тестирование и отладка соединения между двумя устройствами**
**Тип:** Тестирование
**Приоритет:** Medium
**Описание:**
Протестировать установление видеосвязи между двумя физическими устройствами в разных сетях. Убедиться, что базовый сценарий "добавление контакта -> звонок -> ответ -> разговор -> завершение" работает корректно.

**Промт для Cursor:**
```
Нам необходимо провести интеграционное тестирование. Создай два билда нашего приложения (apk/ipa или через Expo Go).
1.  Протестируй сценарий: на устройстве А генерируется ссылка-приглашение -> отправляется мессенджером на устройство Б -> устройство Б добавляет контакт -> устройство А звонит -> устройство Б отвечает -> проверяется двусторонняя аудио- и видеосвязь.
2.  Логируй ключевые этапы установления соединения WebRTC (создание офера, получение ответа, обмен ICE-кандидатами) с помощью `console.debug`, чтобы в случае ошибок можно было найти причину.
3.  Протестируй завершение вызова с обеих сторон.
4.  Если соединение не устанавливается в разных сетях, исследуй необходимость добавления публичного STUN-сервера в конфигурацию `RTCPeerConnection`.
```